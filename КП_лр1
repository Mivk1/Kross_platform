import kotlin.math.*
import java.util.regex.Pattern

fun getFloatInput(prompt: String, errorMessage: String = "Пожалуйста, введите корректное значение!"): Double {
    try {
        print(prompt)
        val value = readLine()!!.trim()

        // Проверка на целые числа без точки (01, 001 и т.д.)
        if (Pattern.matches("^0+[1-9].*", value)) {
            println("Для дробных чисел используйте точку или запятую")
            return getFloatInput(prompt, errorMessage)
        }

        // Учет значений с точкой и запятой
        val normalizedValue = value.replace(',', '.')
        return normalizedValue.toDouble()
    } catch (e: Exception) {
        println(errorMessage)
        return getFloatInput(prompt, errorMessage)
    }
}

fun getPositiveFloatInput(
    prompt: String,
    errorMessage: String = "Пожалуйста, введите положительное дробное число!"
): Double {
    val value = getFloatInput(prompt, "Пожалуйста, введите число!")
    if (value <= 0) {
        println(errorMessage)
        return getPositiveFloatInput(prompt, errorMessage)
    }
    return value
}

// Проверка точности вычисления
fun getAccurate(prompt: String): Double {
    val value = getPositiveFloatInput(prompt)
    if (value >= 1) {
        println("Точность вычисления должна быть меньше 1 (например, 0.1, 0.01, 0.001)")
        return getAccurate(prompt)
    }
    return value
}

fun calculateSinMaclaurin(x: Double, epsilon: Double): Double {
    // Нормализация угла для больших значений
    var normalizedX = x % (2 * PI)
    if (normalizedX > PI) {
        normalizedX -= 2 * PI
    } else if (normalizedX < -PI) {
        normalizedX += 2 * PI
    }

    fun term(n: Int): Double {
        val sign = if (n % 2 == 0) 1.0 else -1.0
        val exponent = 2 * n + 1
        val numerator = normalizedX.pow(exponent)
        val denominator = (1..exponent).fold(1.0) { acc, i -> acc * i }
        return sign * numerator / denominator
    }

    tailrec fun sumTerms(n: Int, currentSum: Double): Double {
        val currentTerm = term(n)
        val newSum = currentSum + currentTerm
        return if (abs(currentTerm) < epsilon) {
            newSum
        } else {
            sumTerms(n + 1, newSum)
        }
    }

    return sumTerms(0, 0.0)
}

fun main() {
    val x = getFloatInput("Введите значение x: ")
    val epsilon = getAccurate("Введите точность вычисления (например, 0.0001): ")

    val mySin = calculateSinMaclaurin(x, epsilon)
    val mathSin = sin(x)
    val difference = abs(mySin - mathSin)

    println("\nРезультаты:")
    println("Ряд Маклорена: ${"%.10f".format(mySin)}")
    println("math.sin():    ${"%.10f".format(mathSin)}")
    println("Разница:       ${"%.2e".format(difference)}")
}
